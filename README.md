# Проект балансировщика нагрузки

## 1. Требования к проекту

Для успешного развертывания проекта убедитесь, что установлены следующие инструменты:

- **Docker**
- **Postman** (или любой другой инструмент для тестирования API)

## 2. Настройка переменных окружения

Создайте файл `.env` в корне проекта и добавьте следующие переменные:

```properties
# Конфигурация базы данных
DB_USER=postgres
DB_PASSWORD=password
DB_HOST=postgres
DB_PORT=5432
DB_NAME=load-balancer
DB_URL=postgresql://${DB_USER}:${DB_PASSWORD}@${DB_HOST}:${DB_PORT}/${DB_NAME}?sslmode=disable

# Конфигурация приложения
APP_PORT=8080
```
Или же можно скопировать данные из файла `.env.example`.

## 3. Настройка данных серверов, на которые будут прооксироваться запросы

В файле config.yaml, который находится в корне проекта, присутствует список 
серверов. Выглядит он так:

```
  - url: "http://host.docker.internal:8003"
    weight: 1
  - url: "http://host.docker.internal:8004"
    weight: 2
```
Проще всего запустить несколько серверов с помощью команд:
```
python3 -m http.server 8003 --bind 0.0.0.0 &
python3 -m http.server 8004 --bind 0.0.0.0 &
```
Таким образом запустятся два бэкенда, на которые будут проксироваться запросы.
Если вы используете другой вариант, то указывайте свои ссылки.
Веса используются для алгоритма Round-Robin. Чем больше вес - тем больше
запросов отправит балансировщик на этот сервер.

## 4. Запуск проекта

1. Убедитесь, что установлены Docker.
2. Выполните команду для запуска всех сервисов:
   ```bash
   docker-compose up --build
   ```
3. При стандартной конфигурации файла .env после успешного запуска
приложение будет доступно по адресу: `http://localhost:8080`.

## 5. HTTP-эндпоинты

В проекте присутствует CRUD для взаимодействия с клиентами из бд - ручка /clients.
А также отдельная ручка /requests для проксирования запросов на сервера, указанные
в config.yaml файле.

Алгоритм **Round-Robin** используется для распределения входящих запросов между пулом бэкенд-серверов.
В данном проекте реализован **взвешенный Round-Robin**, который учитывает вес каждого бэкенда.
Чем больше вес сервера, тем больше запросов он получает.
Для начала, список бэкендов и их веса задаются в конфигурационном файле config.yaml.
Каждый бэкенд содержит URL и вес. Выбор бэкенда осуществляется следующим образом:
- Если буфер бэкендов пуст, алгоритм перебирает список бэкендов, начиная с глобального индекса (`counter`).
- Для каждого бэкенда его вес используется для добавления его в буфер несколько раз (`weight - 1`).
- Если же буфер не пуст - из него выбирается первый бэкенд, а индекс (`counter`) сдвигается.
- После выбора бэкенда запрос перенаправляется на выбранный бэкенд с помощью `httputil.ReverseProxy`.

### Пример:
Если у вас есть два бэкенда:
- `http://backend1` с весом 1
- `http://backend2` с весом 2

Алгоритм распределит запросы следующим образом:
- Первый запрос: `http://backend1`
- Второй запрос: `http://backend2`
- Третий запрос: `http://backend2`
- Четвертый запрос: `http://backend1` (и так по кругу)

Для ограничения частоты запросов используется алгоритм **Token Bucket**. Этот алгоритм позволяет каждому клиенту выполнять запросы с определенной скоростью, не превышая заданного лимита.

Для каждого клиента создается отдельный "бакет", который хранит:
- `Capacity` — максимальное количество токенов.
- `Tokens` — текущее количество токенов.
- `RatePerSec` — скорость пополнения токенов (токенов в секунду).
- `LastRefill` — время последнего пополнения.

Каждую секунду горутина `refillTokens` обновляет количество токенов для всех клиентов.
Токены добавляются на основе времени, прошедшего с момента последнего пополнения.
При каждом запросе к ручке **/requests** происходит проверка, есть ли у клиента доступные токены.
- Если токены есть, запрос разрешается, и один токен удаляется.
- Если токенов нет, запрос отклоняется с кодом `429 Too Many Requests`.

Если клиент отсутствует в системе, для него создается новый бакет с стандартными значениями.
Default values:
``` 
Capacity:   10,
Tokens:     10,
RatePerSec: 1,
LastRefill: time.Now(),
```

### 5.1. Получение списка клиентов
**Метод:** `GET`  
**URL:** `/clients`  
**Ответ:**
```json
{
    "clients": [
        {
            "client_id": "172.18.0.1:49586",
            "capacity": 10,
            "rate_per_sec": 1
        }
    ]
}
```

### 5.2. Создание клиента
**Метод:** `POST`  
**URL:** `/clients`  
**Пример тела запроса:**
```json
{
    "client_id": "172.18.0.1:49586",
    "capacity": 10,
    "rate_per_sec": 1
}
```
P.S: client_id можно оставить пустым, тогда в б.д. сохранится
ip клиента в качестве client_id.
Это будет выглядеть так:
```json
{
    "client_id": "",
    "capacity": 10,
    "rate_per_sec": 1
}
```
**Ответ:**
```json
{
    "status": "success",
    "message": "Клиент успешно создан"
}
```

### 5.3. Обновление клиента
**Метод:** `PUT`  
**URL:** `/clients`  
**Пример тела запроса:**
```json
{
    "client_id": "172.18.0.1:49586",
    "capacity": 20,
    "rate_per_sec": 5
}
```
**Ответ:**
```json
{
    "status": "success",
    "message": "Клиент успешно обновлен"
}
```

### 5.4. Удаление клиента
**Метод:** `DELETE`  
**URL:** `/clients?client_id=172.18.0.1:49586`  
**Ответ:**
```json
{
    "status": "success",
    "message": "Клиент успешно удален"
}
```


### 5.5. Обработка запросов
**Метод:** `GET`  
**URL:** `/request`  
**Заголовок:** `client_id` (обязательный)  
**Примеры ответов:**
- Если запрос разрешен:
  ```json
  {
      "status": "success",
      "message": "Запрос перенаправлен на бэкенд"
  }
  ```
- Если превышен лимит запросов:
  ```json
  {
      "error": "Превышен лимит запросов"
  }
  ```

## 6. Примечания

- **Ограничение скорости (Rate Limiting)**: Для каждого клиента используется алгоритм Token Bucket. При превышении лимита возвращается статус `429 Too Many Requests`.
- **Балансировка нагрузки**: Запросы распределяются между бэкендами с использованием алгоритма взвешенного Round-Robin.
- **Логирование**: Все события (успешные запросы, ошибки, превышение лимитов) записываются в консоль.

## 7. Тестирование API

Для тестирования API используйте Postman или `curl`. Примеры запросов:

### Получение списка клиентов:
```bash
curl -X GET http://localhost:8080/clients
```

### Создание клиента:
```bash
curl -X POST http://localhost:8080/clients \
-H "Content-Type: application/json" \
-d '{
    "client_id": "172.18.0.1:49586",
    "capacity": 10,
    "rate_per_sec": 1
}'
```

### Обновление клиента:
```bash
curl -X PUT http://localhost:8080/clients \
-H "Content-Type: application/json" \
-d '{
    "client_id": "172.18.0.1:49586",
    "capacity": 20,
    "rate_per_sec": 5
}'
```

### Удаление клиента:
```bash
curl -X DELETE "http://localhost:8080/clients?client_id=172.18.0.1:49586"
```

### Обработка запроса:
```bash
curl -X GET http://localhost:8080/requests \
-H "client_id: 172.18.0.1:49586"
```

## 8. Завершение работы

Для остановки всех сервисов выполните:
```bash
docker-compose down
```


# Тестовое задание для Cloud.ru Camp

**Цель:** Реализовать простой балансировщик нагрузки, который принимает входящие HTTP-запросы и распределяет их по пулу бэкенд-серверов. Задание будет оценивать ваши знания Go, умение работать с горутинами, сетевыми запросами, конфигурацией и логированием. В задании присутствует несколько частей, но даже если ты сделал(а) всего одну часть, смело присылай решение, мы его в любом случае рассмотрим и дадим обратную связь. Дополнительные пункты для размышления не являются обязательными, а служат скорее для подсказки возможных вариантов реализации или расширения проекта.

## 1. Вопросы для разогрева

1. Опишите самую интересную задачу в программировании, которую вам приходилось решать?
2. Расскажите о своем самом большом факапе? Что вы предприняли для решения проблемы?
3. Каковы ваши ожидания от участия в буткемпе?

---

## 2. Разработка HTTP-балансировщика нагрузки на Go
### Часть 1. Балансировщик нагрузки
**Основной функционал:**
- Реализовать HTTP-сервер, который принимает входящие запросы (например, на порту 8080).
- При получении запроса балансировщик должен пересылать его на один из заранее заданных бэкенд-серверов. Адреса серверов можно задавать через конфигурационный файл или переменные окружения.
- Использовать стандартный HTTP-пакет Go (net/http) для работы с запросами и для переадресации (reverse proxy, например, с использованием пакета net/http/httputil).

**Распределение запросов:**
- Реализовать алгоритм распределения запросов по бэкендам (минимум – round-robin).
- Балансировщик должен корректно обрабатывать ситуацию, когда один или несколько бэкендов недоступны (выводить понятное сообщение об ошибке или перенаправлять запросы на работающие серверы).

**Параллелизм и конкурентность:**
- Обеспечить одновременную обработку нескольких запросов с использованием горутин.
- Гарантировать корректную работу в условиях конкурентных вызовов (избегать гонок данных).

**Обработка ошибок:**
- Реализовать обработку ошибок при обращении к бэкендам.
- Выводить понятные сообщения ошибок в лог (например, при недоступности сервера).

**Логирование:**
- Реализовать базовое логирование входящих запросов, ошибок и событий (например, смены бэкенда при сбое одного из серверов). Можно использовать стандартный пакет log или другую библиотеку для логирования.

**Конфигурация:**
- Балансировщик должен получать список бэкендов и порт для прослушивания через внешний конфигурационный файл (JSON или YAML) или через параметры командной строки.
- Конфигурация должна быть независима от кода (изменения конфигурации без перекомпиляции).

### Часть 2. Реализация Rate-Limiting
Требуется разработать модуль для ограничения частоты запросов (rate-limiting) на основе алгоритма Token Bucket. Модуль должен защищать внутренние сервисы от перегрузок, обеспечивать честное распределение ресурсов между клиентами и корректно обрабатывать высокую нагрузку.

**Функциональные требования:**

**Реализация алгоритма Token Bucket:**
- Каждому клиенту (IP или API-ключ) выделяется отдельный **bucket** токенов.
- Настройки bucket: количество токенов (емкость), скорость пополнения.
- Запрос считается допустимым, если в bucket клиента есть токен. В противном случае — отклоняется.

**Гранулярное ограничение:**
- Отслеживать состояние каждого клиента (IP/API-ключ)
- Поддерживать возможность настройки разных лимитов для разных клиентов.
- Настройки для разных клиентов можно сохранять в базе данных

**Автоматическое пополнение токенов:**
- Использовать `time.Ticker` для периодического пополнения токенов в buckets.
- Гарантировать атомарность операций с токенами (проверка, извлечение, пополнение).

**Конкурентность:**
- Методы обработки запросов и обновления состояния buckets должны быть потокобезопасными.
- Обеспечить минимальные блокировки для максимизации производительности.

Требуется подготовить README с описанием сборки и запуска проекта.

### Будет здорово, если:
- Архитектура проекта будет модульной: разделите код на логически обособленные пакеты (например, для логики распределения, работы с конфигурацией и реализации HTTP-сервера).
- Приветствуется чистота кода, понятное и подробное комментирование, а также применение интерфейсов для упрощения замены реализаций.
- Оценка задания будет проводиться не только на основе реализованного функционала, но и на основе качества кода (структурирование, тестируемость, документация).
- Напишите Dockerfile и docker-compose.yml для развертывания сервиса и БД 
- Добавите интеграционные тесты с использованием `go test -bench=. -race`.
- Пример нагрузки через Apache Bench (`ab -n 5000 -c 1000 http://localhost:8080/`).


### Дополнительные пункты для размышления
**Поддержка нескольких алгоритмов распределения:**
- Помимо round-robin, реализовать или предусмотреть возможность использования алгоритмов «least connections» или случайного распределения запросов.

**Здоровье бэкендов (Health Checks):**
- Добавить механизм периодических проверок состояния каждого бэкенд-сервера.
- При обнаружении недоступного сервера временно исключать его из пула, а при восстановлении работы возвращать обратно.

**Graceful Shutdown:**
- Реализовать корректное завершение работы балансировщика (обработка сигнала SIGINT или SIGTERM), чтобы завершить обработку текущих запросов без потери данных.

**CRUD для управления клиентами:**
- API для добавления/удаления клиентов (IP/API-ключей) и настройки их лимитов.
- Пример эндпоинта:
    `POST /clients { "client_id": "user1", "capacity": 100, "rate_per_sec": 10 }`

**Персистентность:**
- Сохранять состояние клиентов (текущие токены, настройки) в БД или файле.
- Использовать конфигурационный файл для дефолтных лимитов.

**Обработка ошибок:**
- Возвращать структурированные JSON-ошибки с кодом и описанием.
- Пример:
    `{ "code": 429, "message": "Rate limit exceeded" }`